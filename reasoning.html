<!doctype html>
<html lang="en">

    <head>
        <meta charset="utf-8">

        <title>Explainable Reasoning in Face of Contradictions: From Humans to Machines
        </title>

        <meta name="description" content="Explainable Reasoning in Face of Contradictions: From Humans to Machines">
        <meta name="author" content="Timotheus Kampik">

        <meta name="apple-mobile-web-app-capable" content="yes">
        <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

        <meta name="viewport" content="width=device-width, initial-scale=1.0">

        <link rel="stylesheet" href="css/reset.css">
        <link rel="stylesheet" href="css/reveal.css">
        <link rel="stylesheet" href="css/theme/black.css" id="theme">
        <script src="./js/sigma.min.js"></script>
        <script src="./js/sigma.renderers.parallelEdges.min.js"></script>
        <script src="./js/sigma.layout.noverlap.min.js"></script>
        <script src="./js/sigma.plugins.animate.min.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/sweetalert/2.1.2/sweetalert.min.js" integrity="sha512-AA1Bzp5Q0K1KanKKmvN/4d3IRKVlv9PYgwFPvm32nPO6QS8yH1HO7LbgB1pgiOxPtfeg5zEn2ba64MUcqJx6CA==" crossorigin="anonymous"></script>

        <!-- Theme used for syntax highlighting of code -->
        <link rel="stylesheet" href="lib/css/monokai.css">

        <!-- Printing and PDF exports -->
        <script>
            var link = document.createElement( 'link' );
            link.rel = 'stylesheet';
            link.type = 'text/css';
            link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
            document.getElementsByTagName( 'head' )[0].appendChild( link );
        </script>

        <!--[if lt IE 9]>
        <script src="lib/js/html5shiv.js"></script>
        <![endif]-->
    </head>

    <body>

        <div class="reveal">
                <div class='footer'>
                    <span class="footer-text">Kampik & Gabbay. EXTRAAMAS 2021.</span>
                    <img class="wasp-logo" src="./WASP.png" alt="WASP logo"/>
                    <img class="umu-logo" src="./umu.png" alt="UmU logo"/>
                </div>

            <!-- Any section element inside of this container is displayed as a slide -->
            <div class="slides">
                <section>
                    <h3>Explainable Reasoning in Face of Contradictions: From Humans to Machines
                    </h3>
                    <p>
                        <small><strong>Dov Gabbay</strong> </small><br>
                        <small>Paper: Kampik & Gabbay. <em>Explainable Reasoning in Face of Contradictions: From Humans to Machines.</em></small>
                    </p>
                </section>  

                    <section data-markdown>
                        #### Outline

                        * We claim that a key characteristic of intelligent behavior is the ability to make and **explain** decisions in the face of contradictions.

                        * We motivate this claim by looking at research in micro-economic theory and behavioral economics.

                        * We identify relevant existing and ongoing research on non-monotonic reasoning and highlight limitations.

                        * We outline a set of future research directions.
                        
                    </section>

                    <section    >
                        <h4>What is (Artificial) Intelligence?</h4>

                        <img class="scenario-img" src="./Deep_Blue.jpg">    
                        <img class="scenario-img" src="./Go.JPG">
                        <img class="scenario-img" src="./starcraft.jpg">
                        
                    </section>

                    <section>
                        <h4>What is (Artificial) Intelligence?</h4> 

                        <img src="./belief_revision.png" style="border: none; background: none; box-shadow: none;">
                        
                    </section> 

                    <section>
                        <h4>How do humans reason?</h4> 
                    </section>



                    <section data-markdown>
                        #### Economic Rationality

                        * Assumptions of economic rationality, **ceteris paribus** (if everything else equal):

                            * "Rational Economic Man" acts according to clear preferences

                            * Has consistent preferences over time
                            
                    </section>

                    <section>
                        <fragment data-markdown>
                        #### Clear Preferences
                        </fragment>
    
                        <br>
                        <fragment data-markdown style="font-size: 33.6px">
                        * Standard economic model for individual decision-making
    
                        * Chooses from $A = \\{a_0, ..., a_n\\}$
                        
                        * Choice function: $A \rightarrow 2^A$
    
                        * Clear preferences: total order of all sets in $2^A$
                        </fragment>
    
                        <fragment data-markdown class="tiny left">
                            Rubinstein, Ariel. *Modeling bounded rationality.* 
                        </fragment>
                </section>
    
                <section>
                    <fragment data-markdown>
                    #### Consistent Preferences (Reference Independence)
                    </fragment>
    
                    <fragment data-markdown style="font-size: 33.6px">
                    * Set of choice options $A, A'$, such that $A \subseteq A'$
                    
                    * Rational man's choices $A^{\*} \subseteq A$ and $A'^{\*} \subseteq A'$
                    
                    * If $A'^{\*} \subseteq A$ then $A^{\*} = A'^{\*}$
                    </fragment>
    
                    <fragment data-markdown class="tiny left">
                        Rubinstein, Ariel. *Modeling bounded rationality.*
                    </fragment>
                </section>

                <section>
                    <fragment data-markdown>
                    #### Example

                    * We go to a caf√©, on the menu: `tea and coffee`

                        * We choose `coffee`

                    * Next day, one the menu: `tea, coffee, and cookie`
                </fragment>
                <ul>
                    <li>We choose `tea and cookie`. Are we rational?  <br><button id="tea-cookie" value="" onclick="swal('Yes!', 'We establish that {tea, cookie} is preferred over all other options. Because {tea, cookie} was not an option in the previous scenario, our prefences are consistent.', 'success')">Check answer</button>

                    <li>We choose `tea`. Are we rational? <br><button id="tea" value="" onclick="swal('No!', 'We establish that {tea} is preferred over all other options. Because {tea} was an option in the previous scenario, but we chose {coffee} our prefences are inconsistent: we switched from {coffee} is preferred over {tea} to {tea} is preferred over {coffee}.', 'error')">Check answer</button>
                </ul>
  
                </section>
                
                <section>
                <h4>Bounded Rationality</h4>
                <img src="./kahneman_2.png" width="325px"\>
                        <div  style="font-size: 26px; float: right; width: 250px; text-align: center; margin-top: 15px;">
                            <ul>
                                <li> By now, we know that economic rationality is not a good model of human (intelligent) decision-making. 
                                </li>
                                <li>Economists try to adjusts their models accordingly.</li>
                            </ul>
                        </div>
                        <fragment data-markdown class="tiny left">
                            Kahneman, Daniel. *Modeling bounded rationality.* 
                            Rubinstein, Ariel. *Modeling bounded rationality.*
                        </fragment>
                </section>

                <section data-markdown>
                    #### Consistent Preferences in Knowledge-based Systems

                    * We want to determine the relevant citizenship (passports) of a client

                    * Example: case handling of immigration or tax administration

                    * We use decision management software (a real-world system)

                    * The decision models can be deployed to high-scalability engines such as [jDMN](https://goldmansachs.github.io/jdmn/)
                        
                </section>

                <section>
                    <div class="signavio-interactive-content">
                        <iframe
                                class="signavio-simulation"
                                width="1000"
                                height="650"
                                style="background-color:#fff"
                                src="https://editor.signavio.com/p/bdmsimulation/9616b74b03bb47a8becd1cc945d1b7e9?authkey=f1b186db213e8ff377b3a19ad4c67266f7e953c3bbd382e9d28f6214bdc357ac#/model/9616b74b03bb47a8becd1cc945d1b7e9/decision/sid-D65E0F49-022C-4333-A4A2-F12F0650A7E0/simulation"
                                frameborder="0"
                                allowfullscreen="1"
                        >
                            &nbsp;
                        </iframe>
                    </div>
                </section>


                <!--<section style="margin-top: 100px;" data-background-iframe="https://editor.signavio.com/p/bdmsimulation/9616b74b03bb47a8becd1cc945d1b7e9?authkey=f1b186db213e8ff377b3a19ad4c67266f7e953c3bbd382e9d28f6214bdc357ac#/model/9616b74b03bb47a8becd1cc945d1b7e9/decision/sid-D65E0F49-022C-4333-A4A2-F12F0650A7E0/simulation" data-background-interactive>
                </section>-->

                <section data-markdown>
                    #### Consistent Preferences in Knowledge-based Systems

                    * First, insert ``NO`` (Norwegian citizenship)  
                      &#8594; ``NO`` considered relevant

                    * Then, insert ``UK`` (UK citizenship) as additional option  
                      &#8594; neither ``NO`` nor ``UK`` relevant: not rational!

                    * Automated checks of decision management software don't detect this problem
                        
                </section>

                <section data-markdown>
                    #### What does this have to do with XAgents?
                </section>

                <section>
                <h4>"Reasoning Backwards"</h4>
                <img src="./haidt.jpg" width="325px"\>
                        <div  style="font-size: 26px; float: right; width: 250px; text-align: center; margin-top: 15px;">
                            <ul>
                                <li> We also know that humans "reason backwards". 
                                </li>
                                <li>We commit to a decision intuitively.</li>
                                <li>We make up a line of reasoning if necessary.</li>
                            </ul>
                        </div>
                        <fragment data-markdown class="tiny left">
                            Haidt, Jonathan. *The emotional dog and its rational tail: a social intuitionist approach to moral judgment.*
                        </fragment>
                </section>

                <section data-markdown>
                    #### What does this have to do with contradiction resolution?
                </section>

                <section data-markdown>
                    #### &rarr; Stages of Reasoning/Decision-Making Capabilities
                </section>
                

                <section>
                    <h4>1. Clear preferences: Ability to make a decision no matter what</h4>
                    <img src="./trump.jpg" style="border: none; background: none; box-shadow: none; height: 350px">                        
                </section>

                <section>
                    <h4>2. Consistent preferences: Implied by Decision</h4>
                    
                    <p style="font-size: x-large;">Considering knowledge or <em>justified beliefs</em> about the world</p>
                    <img src="./friedman.jpg" style="border: none; background: none; box-shadow: none; height: 350px">  
                </section>


                <section>
                    <h4>3. "Reasoning backwards": Find an explanation that happens to be satisfied</h4>
                    <img src="./mourinho.jpg" style="border: none; background: none; box-shadow: none; height: 350px">  
                </section>

                <section data-markdown>
                    #### "Reasoning backwards": Find an explanation that happens to be satisfied
                     * **Journalist**: *When you were at Chelsea, you were asked whether you would ever come to the Spurs and you said: 'Never, I love the Chelsea fans too much.' What has changed?*

                    * **Mourinho**: [*That was*] *before I was sacked* [*at Chelsea*].
                </section>

                <section>
                    <h4>4. Principle-based & Evidence-based reasoning</h4>
                    Let us look into this!
                </section>

                <section data-markdown>
                    #### An Argumentation Perspective
                </section>

                <section>
                    <fragment data-markdown>
                    #### Economic Rationality & Abstract Argumentation
                    
                    * $AF = (AR, AT)$; arguments $AR$, e.g.: $\\{a, b, c\\}$, attacks $AT$, e.g.: $\\{(a, b), (b, c)\\}$

                    * Semantics $\sigma(AF)$ returns set of extensions $ES \subseteq 2^{AR}$
                    </fragment>

                    
                </section>

                <section>
                    <fragment data-markdown>
                    #### Normal Expansion
                    
                    * Given $AF = (AR, AT), AF' = (AR', AT')$  AF' normally expands AF iff:

                        * $AR \subseteq AR', AT \subseteq AT'$
                        
                        * $(AT' \setminus AT) \cap (AR \times AR) = \\{\\}$

                    * Only add arguments and attacks, don't change attacks between existing arguments

                    * Denoted by $AF \preceq_N AF'$ (Baumann, Brewka)

                    </fragment>
                    
                </section>

                <section>

                    <fragement data-markdown>
                    #### Clear Preferences

                    * Semantics that are universally defined, or extension-selection "on top of" semantics

                    * Example of absence of clear preferences: Stable semantics, $AF = (\\{a\\}, \\{(a, a)\\})$
                    </fragement>

                    <fragement>
                    <div id="af-1" class="af" style="width:50%!important;min-height: 250px !important;"></div>
                    <script>
                        // Ask sigma to draw it
                        window.addEventListener('load', (
                            event) => {
                                s = new sigma(
                                {
                                    renderer: {
                                    container: document.getElementById('af-1'),
                                    type: 'canvas'
                                    },
                                    settings: {
                                        edgeLabelSize: 'fixed',
                                        defaultLabelSize: 30,
                                        minArrowSize: 10,
                                        maxNodeSize: 25,
                                        maxEdgeLabelSize: 20,
                                        defaultLabelColor: '#fff',
                                        defaultEdgeSize: 3,
                                        maxEdgeSize: 3,
                                        mouseWheelEnabled: true,
                                        sideMargin: 0.05
                                    }
                                }
                                )
    
                                // Create a graph object
                                window.carGraphInitial = {
                                nodes: [
                                    { id: "a", label: "a", x: 0, y: 0, size: 25, color: '#fff' },
                                    //{ id: "b", label: "b", x: 0, y: 1, size: 25, color: '#fff' },
                                    // { id: "c", label: "c", x: 1, y: 1, size: 25, color: '#fff' }
                                ],
                                edges: [
                                    { id: "e0", source: "a", target: "a", color: '#fff', type:'curvedArrow', count:0, size: 3}
                                    //{ id: "e1", source: "b", target: "c", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                    //{ id: "e2", source: "polo", target: "porsche", color: '#fff', type:'curvedArrow', count:0, size: 3}
                                ]
                                }
                                // Load the graph in sigma
                                s.graph.read(carGraphInitial)
    
                                // Start the algorithm:
                            s.refresh()
                            }
                        )
                    </script>
                    </fragement>


                </section>

                <section>
                    <fragment data-markdown>
                    #### Clear Preferences

                    * Q: Is uniqueness required?

                    * Answer: not necessarily, because we know how to break ties
                    </fragment>

                </section>

                <section>
                    <fragment data-markdown>
                    #### Consistent Preferences

                    * Argumentation framework $AF = (AR, AT)$

                    * Semantics $\sigma$, extensions $ES = \sigma(AF)$

                    * Conclusion $E \in ES, E \subseteq AR$ **implies** preferences: $\forall S \in AR, E \succeq S$

                    * Consistent preferences when **normally expanding** $AF$ (Economics' *ceteris paribus* assumption)
                   
                    </fragment>

                </section>

                <section>
                    <fragment>
                        <h4>(In)consistent Preferences</h4> 
                            <table style="min-width:900px!important;min-height: 900px !important;">
                                <tr>
                                    <td>
                                        <div style="width:50%!important;min-height: 250px !important;" id="af-2b" class="af"></div>
                                        <div style="width:50%!important;min-height: 20px !important;" class="af">$\{a\} \succeq \{\}$</div>
                                        
                                    </td>
                                    <td>
                                        <div style="width:50%!important;min-height: 250px !important;" id="af-2c" class="af"></div>
                                        <div style="width:50%!important;min-height: 20px !important;" class="af">$\{\} \succeq \{a\}$</div>
                                    </td>
                                </tr>
                            </table>
                        </fragment>
                        <script>
                            // Ask sigma to draw it
                            window.addEventListener('load', (
                                event) => {
                                    s = new sigma(
                                    {
                                        renderer: {
                                        container: document.getElementById('af-2b'),
                                        type: 'canvas'
                                        },
                                        settings: {
                                            edgeLabelSize: 'fixed',
                                            defaultLabelSize: 30,
                                            minArrowSize: 10,
                                            maxNodeSize: 25,
                                            maxEdgeLabelSize: 20,
                                            defaultLabelColor: '#fff',
                                            defaultEdgeSize: 3,
                                            maxEdgeSize: 3,
                                            mouseWheelEnabled: true,
                                            sideMargin: 0.05
                                        }
                                    }
                                    )
    
                                    // Create a graph object
                                    window.carGraphInitial = {
                                    nodes: [
                                        { id: "a", label: "a", x: 0, y: 0, size: 25, color: '#73A790' }
                                        // { id: "c", label: "c", x: 1, y: 1, size: 25, color: '#fff' }
                                    ],
                                    edges: [
                                        //{ id: "e2", source: "polo", target: "porsche", color: '#fff', type:'curvedArrow', count:0, size: 3}
                                    ]
                                    }
                                    // Load the graph in sigma
                                    s.graph.read(carGraphInitial)
    
                                    // Start the algorithm:
                                s.refresh()
                                }
                            )
                        </script>
                        <script>
                            // Ask sigma to draw it
                            window.addEventListener('load', (
                                event) => {
                                    s = new sigma(
                                    {
                                        renderer: {
                                        container: document.getElementById('af-2c'),
                                        type: 'canvas'
                                        },
                                        settings: {
                                            edgeLabelSize: 'fixed',
                                            defaultLabelSize: 30,
                                            minArrowSize: 10,
                                            maxNodeSize: 25,
                                            maxEdgeLabelSize: 20,
                                            defaultLabelColor: '#fff',
                                            defaultEdgeSize: 3,
                                            maxEdgeSize: 3,
                                            mouseWheelEnabled: true,
                                            sideMargin: 0.3
                                        }
                                    }
                                    )
    
                                    // Create a graph object
                                    window.carGraphInitial = {
                                    nodes: [
                                        { id: "a", label: "a", x: 0, y: 0, size: 25, color: '#fff' },
                                        { id: "b", label: "b", x: 0, y: 1, size: 25, color: '#fff' },
                                        { id: "c", label: "c", x: 1, y: 1, size: 25, color: '#fff' },
                                        { id: "d", label: "d", x: 1, y: 0, size: 25, color: '#fff' }
                                    ],
                                    edges: [
                                        { id: "e1", source: "b", target: "c", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e2", source: "c", target: "d", color: '#fff', type:'arrow', count:0, size: 3},
                                        { id: "e3", source: "b", target: "a", color: '#fff', type:'arrow', count:0, size: 3},
                                        { id: "e4", source: "d", target: "b", color: '#fff', type:'arrow', count:0, size: 3}
                                    ]
                                    }
                                    // Load the graph in sigma
                                    s.graph.read(carGraphInitial)
    
                                    // Start the algorithm:
                                s.refresh()
                                }
                            )
                        </script>
                </section>



                <section>
                    <fragment data-markdown>
                    #### Reasoning Backwards

                    * Finding arguments that fit the conclusion

                    * Searching for a line of reasoning that happens to suite the narrative  
                    (a formal principle that happens to be satisfied)

                    <!--* Referring to the general properties of a semantics-->

                    </fragment>
                </section>


                <section>
                    <fragment>
                        <h4>Reasoning Backwards</h4> 
                            <table style="min-width:900px!important;">
                                <tr style="height: 150px!important">
                                    <td style="height: 150px!important">
                                        <div style="width:50%!important;max-height: 150px !important;" id="af-3a" class="af"></div>
                                        <div style="width:50%!important;max-height: 20px !important;" class="af">$\{a\} \succeq \{b\}$</div>
                                        
                                    </td>
                                    <td style="height: 150px!important">
                                        <div style="width:50%!important;max-height: 150px !important;" id="af-3b" class="af"></div>
                                        <div style="width:50%!important;min-height: 20px !important;" class="af">$\{b\} \succeq \{a\}$</div>
                                    </td>
                                </tr>
                            </table>
                            
                        </fragment>
                        <script>
                            // Ask sigma to draw it
                            window.addEventListener('load', (
                                event) => {
                                    s = new sigma(
                                    {
                                        renderer: {
                                        container: document.getElementById('af-3a'),
                                        type: 'canvas'
                                        },
                                        settings: {
                                            edgeLabelSize: 'fixed',
                                            defaultLabelSize: 30,
                                            minArrowSize: 10,
                                            maxNodeSize: 25,
                                            maxEdgeLabelSize: 20,
                                            defaultLabelColor: '#fff',
                                            defaultEdgeSize: 3,
                                            maxEdgeSize: 3,
                                            mouseWheelEnabled: true,
                                            sideMargin: 0.3
                                        }
                                    }
                                    )
    
                                    // Create a graph object
                                    window.carGraphInitial = {
                                    nodes: [
                                        { id: "a", label: "a", x: 0, y: 0, size: 25, color: '#73A790' },
                                        { id: "b", label: "b", x: 1, y: 0, size: 25, color: '#fff' }
                                    ],
                                    edges: [
                                        { id: "e0", source: "a", target: "b", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e1", source: "b", target: "a", color: '#fff', type:'curvedArrow', count:0, size: 3}
                                    ]
                                    }
                                    // Load the graph in sigma
                                    s.graph.read(carGraphInitial)
    
                                    // Start the algorithm:
                                s.refresh()
                                }
                            )
                        </script>
                        <script>
                            // Ask sigma to draw it
                            window.addEventListener('load', (
                                event) => {
                                    s = new sigma(
                                    {
                                        renderer: {
                                        container: document.getElementById('af-3b'),
                                        type: 'canvas'
                                        },
                                        settings: {
                                            edgeLabelSize: 'fixed',
                                            defaultLabelSize: 30,
                                            minArrowSize: 10,
                                            maxNodeSize: 25,
                                            maxEdgeLabelSize: 20,
                                            defaultLabelColor: '#fff',
                                            defaultEdgeSize: 3,
                                            maxEdgeSize: 3,
                                            mouseWheelEnabled: true,
                                            sideMargin: 0.3
                                        }
                                    }
                                    )
    
                                    // Create a graph object
                                    window.carGraphInitial = {
                                        nodes: [
                                        { id: "a", label: "a", x: 0, y: 0, size: 25, color: '#fff' },
                                        { id: "b", label: "b", x: 1, y: 0, size: 25, color: '#73A790' }
                                    ],
                                    edges: [
                                        { id: "e0", source: "a", target: "b", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e1", source: "b", target: "a", color: '#fff', type:'curvedArrow', count:0, size: 3}
                                    ]
                                    }
                                    // Load the graph in sigma
                                    s.graph.read(carGraphInitial)
    
                                    // Start the algorithm:
                                s.refresh()
                                }
                            )
                        </script>
                </section>

                <section>
                    <fragment>
                        <h4>Reasoning Backwards</h4> 
                        <div id="af-3c" class="af" style="width:50%!important;min-height: 250px !important;"></div>
                            
                        </fragment>
                        <script>
                            // Ask sigma to draw it
                            window.addEventListener('load', (
                                event) => {
                                    s = new sigma(
                                    {
                                        renderer: {
                                        container: document.getElementById('af-3c'),
                                        type: 'canvas'
                                        },
                                        settings: {
                                            edgeLabelSize: 'fixed',
                                            defaultLabelSize: 30,
                                            minArrowSize: 10,
                                            maxNodeSize: 25,
                                            maxEdgeLabelSize: 20,
                                            defaultLabelColor: '#fff',
                                            defaultEdgeSize: 3,
                                            maxEdgeSize: 3,
                                            mouseWheelEnabled: true,
                                            sideMargin: 0.3
                                        }
                                    }
                                    )
    
                                    // Create a graph object
                                    window.carGraphInitial = {
                                        nodes: [
                                        { id: "a", label: "a", x: 0, y: 0, size: 25, color: '#fff' },
                                        { id: "b", label: "b", x: 1, y: 0, size: 25, color: '#73A790' },
                                        { id: "c", label: "c", x: 0, y: 1, size: 25, color: '#73A790' }
                                    ],
                                    edges: [
                                        { id: "e0", source: "a", target: "b", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e1", source: "b", target: "a", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e2", source: "c", target: "a", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e3", source: "a", target: "c", color: '#fff', type:'curvedArrow', count:0, size: 3}
                                    ]
                                    }
                                    // Load the graph in sigma
                                    s.graph.read(carGraphInitial)
    
                                    // Start the algorithm:
                                s.refresh()
                                }
                            )
                        </script>
                </section>


                <section>
                    <fragment data-markdown>
                    #### Principle-based / Evidence-based Reasoning

                    * Construct an argumentation framework, one argument at a time

                    * Check principle satisfaction, one argument at a time

                    * Focus on the **effect of change** to a base of contradicting beliefs on the conclusions that are inferred

                    * Apply a cross-disciplinary perspective on human reasoning and decision-making

                    </fragment>
                </section>

                <section data-markdown>
                    #### Research Directions
                </section>

                <section>
                    <fragment data-markdown>
                    #### Automated Reasoning and (Bounded) Economic Rationality

                    * How can we apply principles of (boundedly) rational decision-making to automated (non)-monotonic reasoning?

                    * How should we relax these principles?
                </fragment>
                    <fragment data-markdown class="tiny left">
                        Kampik & Gabbay. *Towards DiArg - An Argumentation-based Dialogue Reasoner*.  
                        Kampik & Nieves. *Abstract Argumentation and the Rational Man*.
                    </fragment>
                </section>

                    
                </section>

                <section>
                    <fragment data-markdown>
                    #### Automated Reasoning and Intuitive Rationality

                    * What principles find humans intuitive?

                    * Are these principles generally applicable, or are there domain-specific or population-specific differences?
                    </fragment>
                    <fragment data-markdown class="tiny left">
                        Cramer & Guillaume. *Empirical cognitive study on abstract argumentation semantics*.  
                        Cramer & Guillaume. *Empirical study on human evaluation of complex argumentation frameworks*.
                    </fragment>
                </section>


                <section data-markdown>
                    #### Principle-based Semantics Design

                    * Well-established, long-running research direction

                    * New/emerging: focus on relational properties:

                      * What happens when **adding a new argument**/attack?

                      * What happens when "forgetting" an argument/attack?

                </section>

                <section>
                    <fragment data-markdown>
                        #### Principle-based Semantics Design
                    </fragment>

                    <fragment data-markdown class="tiny left">
                        Van der Torre & Vesic. *The principle-based approach to abstract argumentation semantics*.  
                        <br>
                        Baroni & Giacomin. *On principle-based evaluation of extension-based argumentation semantics*.  
                        <br>
                        Bauman & Brewka. *Expanding Argumentation Frameworks: Enforcing and Monotonicity Results*.  
                        <br>
                        Rienstra, Sakam & Van der Torre. *Persistence and Monotony Properties of Argumentation Semantics*. 
                        <br> 
                        Kampik & Nieves. *Abstract Argumentation and the Rational Man*.
                    </fragment>   
                </section>

                <section>
                    <fragment data-markdown>
                    #### Burden of Proof/Persuasion

                    * Legal theory: in case of a conflict, place the "burden of persuasion" on one of the parties

                    * Relates to centuries of research on how to resolve logical contradictions

                    * Can we create an abstract framework for managing the burden of persuasion?

                    </fragment>
                    <fragment data-markdown class="tiny left">
                        Calegari & Sartor. *A model for the burden of persuasion in argumentation*.  
                        Prakken & Sartor. *A Logical Analysis of Burdens of Proof*.  
                        Abraham, Gabbay & Schild. *The Handling of Loops in Talmudic Logic*.
                    </fragment>

                </section>

                <section>
                    <fragment data-markdown>
                    #### Integration with Machine Learning

                    * More and more works integrate symbolic reasoning and machine learning

                    * We can learn formal models that satisfy reasoning principles (like monotony properties)

                    * What practical guarantees can we get from these principles?

                    * How can we learn principles?
                </fragment>
                    <!--<fragment data-markdown class="tiny left">
                        Cabrio & Villata. "Five Years of Argument Mining: a Data-driven Analysis." 
                    </fragment>-->

                </section>

                <section>
                    <h4>Example: Learning Principles</h4>
                    <img src="./mourinho.jpg" style="border: none; background: none; box-shadow: none; height: 350px">  
                </section>


                <section>
                    <fragment>
                        <h4>Example: Learning Principles</h4> 
                            <table style="min-width:900px!important;">
                                <tr style="height: 150px!important">
                                    <td style="height: 150px!important">
                                        <div style="width:50%!important;max-height: 250px !important;" id="af-rba" class="af"></div>
                                        <div style="width:50%!important;max-height: 20px !important;" class="af">Positive reward</div>
                                        
                                    </td>
                                    <td style="height: 150px!important">
                                        <div style="width:50%!important;max-height: 250px !important;" id="af-rbb" class="af"></div>
                                        <div style="width:50%!important;min-height: 20px !important;" class="af">Negative reward</div>
                                    </td>
                                </tr>
                            </table>
                            
                        </fragment>
                        <script>
                            // Ask sigma to draw it
                            window.addEventListener('load', (
                                event) => {
                                    s = new sigma(
                                    {
                                        renderer: {
                                        container: document.getElementById('af-rba'),
                                        type: 'canvas'
                                        },
                                        settings: {
                                            edgeLabelSize: 'fixed',
                                            defaultLabelSize: 30,
                                            minArrowSize: 10,
                                            maxNodeSize: 25,
                                            maxEdgeLabelSize: 20,
                                            defaultLabelColor: '#fff',
                                            defaultEdgeSize: 3,
                                            maxEdgeSize: 3,
                                            mouseWheelEnabled: true,
                                            sideMargin: 0.3
                                        }
                                    }
                                    )
    
                                    // Create a graph object
                                    window.carGraphInitial = {
                                    nodes: [
                                        { id: "a", label: "a", x: 0, y: 0, size: 25, color: '#73A790' },
                                        { id: "b", label: "b", x: 1, y: 0, size: 25, color: '#fff' }
                                    ],
                                    edges: [
                                        { id: "e0", source: "a", target: "b", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e1", source: "b", target: "a", color: '#fff', type:'curvedArrow', count:0, size: 3}
                                    ]
                                    }
                                    // Load the graph in sigma
                                    s.graph.read(carGraphInitial)
    
                                    // Start the algorithm:
                                s.refresh()
                                }
                            )
                        </script>
                        <script>
                            // Ask sigma to draw it
                            window.addEventListener('load', (
                                event) => {
                                    s = new sigma(
                                    {
                                        renderer: {
                                        container: document.getElementById('af-rbb'),
                                        type: 'canvas'
                                        },
                                        settings: {
                                            edgeLabelSize: 'fixed',
                                            defaultLabelSize: 30,
                                            minArrowSize: 10,
                                            maxNodeSize: 25,
                                            maxEdgeLabelSize: 20,
                                            defaultLabelColor: '#fff',
                                            defaultEdgeSize: 3,
                                            maxEdgeSize: 3,
                                            mouseWheelEnabled: true,
                                            sideMargin: 0.3
                                        }
                                    }
                                    )
    
                                    window.carGraphInitial = {
                                        nodes: [
                                        { id: "a", label: "a", x: 0, y: 0, size: 25, color: '#fff' },
                                        { id: "b", label: "b", x: 1, y: 0, size: 25, color: '#73A790' },
                                        { id: "c", label: "c", x: 0, y: 1, size: 25, color: '#73A790' }
                                    ],
                                    edges: [
                                        { id: "e0", source: "a", target: "b", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e1", source: "b", target: "a", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e2", source: "c", target: "a", color: '#fff', type:'curvedArrow', count:0, size: 3},
                                        { id: "e3", source: "a", target: "c", color: '#fff', type:'curvedArrow', count:0, size: 3}
                                    ]
                                    }
                                    // Load the graph in sigma
                                    s.graph.read(carGraphInitial)
    
                                    // Start the algorithm:
                                s.refresh()
                                }
                            )
                        </script>
                </section>

                <section data-markdown>
                    #### Example: Learning Principles
                    * Current conclusion is principle-compliant but yields negative reward
                    * Can we tighten or a relax the principle in a way that gives us better rewards?
                    * What about the principle "if in doubt, remain consistent"
                    * We can formalize it, but can we learn it?
                </section>


                <section>
                    <h1>Questions?</h1>
                    <small data-markdown>
                        Special Issue in the Journal of Applied Logics - IfCoLog Journal:  
                        *Explainable Reasoning in Face of Contradictions: Cross-disciplinary Perspectives*
                    </small>
            </section>


            </div>

        </div>

        <script src="js/reveal.js"></script>

        <script>

            // More info https://github.com/hakimel/reveal.js#configuration
            Reveal.initialize({
                controls: true,
                progress: true,
                center: true,
                hash: true,
                slideNumber: true,

                transition: 'slide', // none/fade/slide/convex/concave/zoom

                // More info https://github.com/hakimel/reveal.js#dependencies
                dependencies: [
                    { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
                    { src: 'plugin/highlight/highlight.js', async: true },
                    { src: 'plugin/search/search.js', async: true },
                    { src: 'plugin/zoom-js/zoom.js', async: true },
                    { src: 'plugin/notes/notes.js', async: true },
                    { src: './plugin/math/math.js', async: true }
                ]
            });

            Reveal.addEventListener( 'slidechanged', function( event ) {
                window.dispatchEvent(new Event('resize'))
                window.dispatchEvent(new Event('resize'))
            } )

        </script>

    </body>
</html>
